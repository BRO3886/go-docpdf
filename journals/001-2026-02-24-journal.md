# Journal Entry 001 - 2026-02-24 - Initial implementation of docx-to-PDF service

## Goal

Build a production-ready Go HTTP service that converts `.docx` files to PDF by shelling out to LibreOffice. Replace Gotenberg for a single use-case: docx → PDF conversion.

## What Changed

- Initialized git repository
- Created proper Go package layout:
  - `cmd/server/main.go` — entry point, mux setup, PORT env support
  - `internal/converter/converter.go` — `Converter` interface + `LibreOffice` struct impl
  - `internal/converter/converter_test.go` — 4 converter-level tests
  - `internal/handler/handler.go` — `Convert` HTTP handler + `Health` handler
  - `internal/handler/handler_test.go` — 10 handler-level tests
  - `Dockerfile` — two-stage build: `golang:1.24-alpine` builder + `alpine:3.21` runtime with libreoffice via apk
- All 14 tests pass
- Manually verified end-to-end with a real `.docx` file against a running server

## Key Insights

**Timeout detection with `exec.CommandContext`:**
`ctx.Err() == context.DeadlineExceeded` is reliably set after `cmd.CombinedOutput()` returns when the process was killed for exceeding the deadline. Must check `ctx.Err()` *after* the call returns, not before.

**Timeout test requires a real sleeping process:**
Using `"sleep"` as the fake binary fails on macOS because `sleep --headless` (the extra args passed by the converter) exits immediately with "illegal option". Fix: write a shell script to `t.TempDir()` that does `sleep 60` and use that as `BinaryPath`.

```go
scriptPath := filepath.Join(tmpDir, "fake-lo.sh")
_ = os.WriteFile(scriptPath, []byte("#!/bin/sh\nsleep 60\n"), 0755)
c := &converter.LibreOffice{BinaryPath: scriptPath, Timeout: 100 * time.Millisecond}
```

**LibreOffice output naming:**
LibreOffice names the PDF after the *input filename stem*. Input must be `input.docx` → output will be `input.pdf` in `outDir`. The converter hardcodes `input.docx` as the temp filename.

**Array comparison for magic bytes:**
Go 1.20+ supports `[4]byte(data[:4]) == docxMagic` directly — cleaner than byte-by-byte loop.

**`sync.Mutex` placement:**
The mutex lives on the handler struct (not a package-level global), which keeps the serialization concern encapsulated and the global state minimal as required by spec.

**Large file rejection — two layers needed:**
`http.MaxBytesReader` rejects at parse time, but we also re-check after `io.ReadAll` with a `LimitedReader` to handle the edge case where multipart overhead lets a slightly-over file slip through the first check.

**Iteration during refactor:**
Started with a flat `package main` layout, then restructured to `cmd/` + `internal/` per user feedback on Go conventions. Required updating all package declarations, import paths, and removing the flat source files.

## Decisions Made

- **`Converter` as an interface in `internal/converter`** — allows the handler package to depend on the interface, and tests to inject a `mockConverter` without importing the real implementation. The mock lives in `handler_test.go` (package `handler_test`) to keep it test-only.
- **Sentinel errors (`ErrTimeout`, `ErrNoOutput`, `ErrConversionFailed`)** — handler switches on `errors.Is()` to map to HTTP status codes without string matching.
- **`LIBREOFFICE_PATH` env var** — defaults to `"libreoffice"` (works in Docker), overridden to `/Applications/LibreOffice.app/Contents/MacOS/soffice` for local Mac dev.
- **No frameworks** — stdlib only (`net/http`, `os/exec`, `sync`, `encoding/json`). Zero external dependencies.
- **`USER nobody` in Dockerfile** — LibreOffice can run as a non-root user; avoids running the service as root in the container.

---
